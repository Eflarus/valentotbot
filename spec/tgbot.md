
**TL;DR:**
Ниже — цельное, формализованное и самодостаточное ТЗ:
— стек: Python 3.12, `python-telegram-bot` 22.5 (async, webhook), PostgreSQL, SQLAlchemy 2 + Alembic, FastAPI, Redis, Docker, `uv`, `black` + `mypy --strict`;
— два этапа: **Этап 1 — бот**, **Этап 2 — админка**;
— multi-link диплинки (отдельные slug’и, не Telegram ID), только текстовые сообщения, анонимные ответы, бесплатное раскрытие автора по его согласию;
— строгая типизация везде, конфиги только из `.env`, устойчивость к рестартам (состояния диалогов и переписка не теряются), никакого палёного ID в `callback_data`;
— чистая архитектура, логирование с ротацией, i18n, бэкапы.

Ниже — ТЗ, готовое к передаче в команду / Codex.

---

# Техническое задание

на разработку Telegram-бота «Анонимные валентинки»

---

## 1. Общие сведения о проекте

**Название проекта:** Telegram-бот «Анонимные валентинки с мультиссылками»
**Заказчик:** eflarus
**Исполнитель:** (eflarus / Codex)

**Краткое описание:**

Необходимо разработать высоконагруженный Telegram-бот, позволяющий пользователям:

* создавать **несколько анонимных ссылок** (deep link) для разных площадок;
* принимать **только текстовые анонимные сообщения** по этим ссылкам;
* анонимно отвечать на них;
* при явном согласии автора сообщения — **бесплатно раскрывать автора** и переходить с ним в личный чат;
* получать удобную статистику по ссылкам и сообщениям.

В дальнейшем (Отдельный этап 2) требуется реализовать веб-админку с полным доступом к данным для администратора.

---

## 2. Стек технологий и общие требования к разработке

### 2.1. Технологический стек

1. **Язык программирования:**

   * Python **3.12** (обязательно).

2. **Telegram-фреймворк:**

   * `python-telegram-bot` **22.5**:

     * асинхронный режим (`ApplicationBuilder`, `async` handlers),
     * **только webhook**, без long polling.

3. **База данных:**

   * PostgreSQL версии **14+**.

4. **ORM и миграции:**

   * SQLAlchemy **2.x** (declarative).
   * Alembic для миграций.

5. **Кэш / рейтлимиты / FSM-пersistence (опционально, рекомендуется):**

   * Redis (например, Redis 6+).

6. **HTTP-слой / API / админка (Этап 2 и служебные эндпоинты):**

   * FastAPI.

7. **Управление зависимостями:**

   * `uv` (с `pyproject.toml` и `uv.lock`).

8. **Контейнеризация:**

   * Docker (минимум один образ для bot-сервиса и один для admin-API, при необходимости можно объединить).
   * `docker-compose` для локальной разработки.
   * Подготовка к деплою в Kubernetes (деплой-манифесты — опционально, но архитектура должна это позволять).

9. **Интернационализация (i18n):**

   * Поддержка минимум двух языков (RU и EN).
   * Использование ключей сообщений и словарей/po-файлов.

10. **ОС и окружение:**

    * Linux-окружение в контейнерах (например, Debian/Ubuntu slim).

---

### 2.2. Требования к качеству кода

1. **Полная типизация:**

   * Все функции и методы **обязаны иметь** аннотации типов аргументов и возвращаемых значений.
   * Все модели, DTO, конфигурационные классы — с типизированными полями.
   * Использование `Any` допускается только в строго обоснованных местах с комментариями.

2. **Статический анализ:**

   * Обязательное использование `mypy` в строгом режиме:

     * минимум: `mypy --strict`.
   * Конфигурация в `pyproject.toml` или отдельном файле `mypy.ini`.

3. **Форматирование и линтинг:**

   * Обязательное использование `black` для форматирования кода.
   * Использование `ruff` для сортировки импортов.
   * `ruff` для линтинга (важно, чтобы он был интегрирован в CI).

4. **Pre-commit hooks (рекомендуется, можно обязательным требованием сделать в CI):**

   * `black`,
   * `ruff`,
   * `mypy` (как минимум в CI, опционально в pre-commit).

---

### 2.3. Конфигурация и переменные окружения

**Жёсткое требование:**
Все параметры конфигурации должны задаваться через `.env` файлы и/или переменные окружения, без захардкоженных секретов и URL в коде.

Пример переменных (минимальный набор):

```env
BOT_TOKEN=123456:ABC-DEF...
BOT_USERNAME=valentines_bot
WEBHOOK_BASE_URL=https://example.com
POSTGRES_HOST=postgres
POSTGRES_PORT=5432
POSTGRES_DB=valentines
POSTGRES_USER=valentines_user
POSTGRES_PASSWORD=super_secret
REDIS_URL=redis://redis:6379/0
APP_ENV=local  # local | staging | production
LOG_LEVEL=INFO
```

Должны быть предусмотрены отдельные файлы:

* `.env.local` — для локальной разработки,
* `.env.staging` — для стейджинга,
* `.env.prod` — для продакшена.

В коде конфигурация должна загружаться через типизированный конфигурационный класс (например, Pydantic Settings).

---

## 3. Архитектура и слои

Используем подход **чистой архитектуры** / layered architecture:

1. **Domain (Core):**

   * Сущности: User, Link, Message, Thread, ThreadMessage, CallbackToken, DialogState (если нужен).
   * Интерфейсы репозиториев.
   * Бизнес-правила: создание ссылок, отправка анонимных сообщений, анонимные ответы, бесплатное раскрытие автора, статус сообщений, статистика.

2. **Application (Use Cases):**

   * Сервисы/юзкейсы:

     * `CreateLinkService`,
     * `ListLinksService`,
     * `SendAnonymousMessageService`,
     * `OpenMessageService`,
     * `ReplyToMessageService`,
     * `RevealAuthorService`,
     * `GetUserStatsService`,
     * `ReportMessageService`,
     * и т.п.
   * Работают только с интерфейсами репозиториев и DTO, не зависят от Telegram/HTTP.

3. **Infrastructure:**

   * Реализации репозиториев для PostgreSQL (SQLAlchemy).
   * Адаптеры для Redis (рейтлимиты, FSM-состояния).
   * Реализация persistence для `python-telegram-bot` (если используется BasePersistence).
   * Логирование, конфигурация, миграции.

4. **Presentation:**

   * Telegram-слой:

     * асинхронные обработчики `python-telegram-bot`,
     * inline-клавиатуры и тексты сообщений,
     * интеграция с use-cases.
   * HTTP / Admin API (FastAPI):

     * будет реализован на Этапе 2.
   * Сериализация/валидация DTO (pydantic).

---

## 4. Этапы работ

### Этап 1 — Telegram-бот (без отдельной веб-админки)

**Результат:** Полностью рабочий бот с:

* мультиссылками (deep link);
* только текстовыми анонимными сообщениями;
* анонимными ответами;
* бесплатным раскрытием автора по его согласию;
* базовой статистикой для пользователей;
* устойчивостью к рестартам (состояния диалогов и переписка не теряются);
* логированием, i18n, бэкапами БД.

### Этап 2 — Админка

**Результат:** Отдельный HTTP-сервис (FastAPI) + UI для:

* просмотра и модерации пользователей, ссылок, сообщений;
* просмотра расширенной статистики;
* служебных операций.

---

## 5. Функциональные требования — Этап 1 (бот)

### 5.1. Роли

1. **AnonSender (анонимный отправитель)** — любой человек, у которого есть диплинк.
2. **Receiver (получатель)** — пользователь, создавший свои ссылки в боте.
3. **Admin (администратор)** — на Этапе 1 может работать только через БД/консоль; полноценный UI на Этапе 2.
4. **System** — фоновые задачи, бэкапы и т.п.

---

### 5.2. Регистрация и команда /start

#### 5.2.1. `/start` без параметров

При первом входе пользователя в бота командой `/start`:

* создать или обновить пользователя в таблице `users`:

  * `telegram_user_id`
  * `username`
  * `first_name`, `last_name`
  * `language_code` из Telegram (если есть)
  * даты `created_at`, `updated_at`.
* Определить язык интерфейса:

  * если пользователь уже выбирал ранее — брать сохранённый язык;
  * иначе использовать `language_code` Telegram, если поддерживается;
  * иначе — язык по умолчанию (например, RU).
* Показать главное меню:

  * “Мои ссылки”
  * “Мои сообщения”
  * “Статистика”
  * “Настройки”
  * “Помощь / FAQ”

#### 5.2.2. `/start <payload>` (deep link)

При вызове `/start link_<slug>`:

* распарсить `slug` (строка после `link_`);
* найти в таблице `links` запись с таким `slug`, `is_active = true`;
* если ссылка не найдена или неактивна:

  * вернуть пользователю сообщение о недействительности/истечении ссылки;
* если ссылка валидна:

  * инициировать сценарий отправки анонимного текста:

    * показать промпт (если задан владельцем ссылки),
    * описать правила анонимности,
    * предложить выбрать режим раскрытия:

      * “Оставаться полностью анонимным (раскрытие запрещено)”
      * “Разрешить бесплатное раскрытие автора”.

---

### 5.3. Управление ссылками (Receiver)

#### 5.3.1. Создание ссылки

Пользователь-получатель (Receiver) может создать несколько ссылок:

1. Вызывает соответствующий пункт меню “Мои ссылки” → “Создать новую ссылку”.
2. Вводит:

   * **Название ссылки** (label), например “Instagram Bio”, “VK профиль”.
   * **Промпт** (опционально) — описание/вопрос, который увидит анонимный отправитель.
3. Система:

   * генерирует уникальный `slug` (короткая строка, НЕ содержащая `telegram_user_id`, `chat_id` и т.п.);
   * сохраняет запись в таблицу `links`.
4. Бот возвращает пользователю диплинк в формате:
   `https://t.me/<BOT_USERNAME>?start=link_<slug>`, и показывает его удобным образом (кнопка “Скопировать ссылку”, текст).

#### 5.3.2. Просмотр и управление ссылками

В разделе “Мои ссылки”:

* Показать список ссылок:

  * label,
  * часть/обрезанный диплинк,
  * количество полученных сообщений.
* Для каждой ссылки — кнопки:

  * “Статистика по ссылке” (кол-во сообщений, ответы и т.п.),
  * “Включить/Выключить” (`is_active`),
  * “Удалить” (soft delete: `deleted_at`).

---

### 5.4. Ограничение контента: только текст

**Обязательное ограничение:**

* Бот принимает и обрабатывает **только текстовые сообщения** как валентинки/ответы:

  * Нет поддержки фото, видео, голосовых, документов, стикеров, GIF, файлов и т.п.
* При получении non-text сообщения:

  * бот отвечает шаблонным текстом (локализованным), что доступен только текст;
  * сообщение **не** сохраняется в БД как валентинка/ответ.

---

### 5.5. Отправка анонимного сообщения (AnonSender)

Сценарий:

1. Пользователь переходит по диплинку `/start link_<slug>`.
2. Бот:

   * валидирует ссылку;
   * показывает промпт и правила анонимности;
   * предлагает выбрать режим раскрытия автора:

     * “Полная анонимность (раскрытие запрещено)”
     * “Разрешить бесплатное раскрытие автора”.
3. После выбора режима:

   * бот просит ввести текст сообщения (с указанием минимальной и максимальной длины, например 1–2000 символов).
4. Пользователь отправляет текст.
5. Бот:

   * валидирует длину;
   * создаёт запись в `messages`:

     * `link_id`
     * `recipient_user_id`
     * `sender_user_id` (Telegram ID отправителя, если он авторизован в боте; допускается null, если это принципиально — можно обсудить, но по умолчанию — сохраняем)
     * `text`
     * `is_reveal_allowed` (bool, из выбора пользователя)
     * `status` (например, NEW)
     * timestamps.
   * отправляет уведомление Receiver’у о новой валентинке.

---

### 5.6. Уведомление и просмотр сообщений (Receiver)

#### 5.6.1. Уведомления о новых валентинках

При создании сообщения:

* Receiver получает в бот:

  * текст: “Новая валентинка по ссылке <label>”,
  * краткий префикс текста (обрезанные первые N символов),
  * inline-кнопки:

    * “Открыть валентинку” → открывает полный просмотр конкретного сообщения.

#### 5.6.2. Раздел “Мои сообщения”

В разделе “Мои сообщения”:

* Фильтры:

  * по ссылке (список `links` пользователя),
  * по статусу (новые / прочитанные / все),
  * по периоду (последние 24 часа, 7 дней, 30 дней).
* Пагинация:

  * inline-кнопки “◀️ / ▶️”.
* При выборе конкретного сообщения:

  * показать:

    * полный текст,
    * название ссылки (label),
    * статус (новое/прочитано),
    * `is_reveal_allowed` — разрешено ли бесплатное раскрытие.

Доступные действия:

* “Ответить анонимно”.
* “Раскрыть автора” (если `is_reveal_allowed == True`).
* “Удалить/Архивировать”.
* “Пожаловаться / Заблокировать автора”.

---

### 5.7. Анонимные ответы и переписка (threads)

Для организации переписки:

1. Вводим сущность `threads` (диалоги):

   * `id`
   * `root_message_id` (исходная валентинка)
   * `created_at`
   * `closed_at` (nullable).

2. Ответы хранятся в таблице `thread_messages`:

   * `id`
   * `thread_id`
   * `from_user_id`
   * `to_user_id`
   * `text`
   * `created_at`
   * `read_at` (nullable).

**Сценарий ответа:**

1. Receiver нажимает “Ответить анонимно”.
2. Бот просит ввести текст ответа.
3. После ввода:

   * создаётся или находится `thread` по `root_message_id`;
   * сохраняется запись в `thread_messages`;
   * отправляется уведомление автору (AnonSender):

     * “Вам ответили на вашу валентинку”,
     * текст ответа,
     * inline-кнопки “Ответить анонимно” и, при раскрытии — “Перейти в чат”.

Все ответы проходят через бота; никакие ID сторон в открытом виде пользователю не показываются до момента раскрытия.

---

### 5.8. Раскрытие автора (бесплатное, по его согласию)

**Важно:** никакого платного/звёздочного функционала **на данном этапе нет**.

Логика:

1. При отправке валентинки автор выбрал:

   * “Разрешить бесплатное раскрытие автора”.
2. В интерфейсе Receiver’а у такого сообщения есть кнопка:

   * “Раскрыть автора”.
3. При нажатии:

   * Бот проверяет `is_reveal_allowed` для сообщения;
   * если `False` — показать уведомление “Автор запретил раскрытие”;
   * если `True` — бот:

     * определяет `sender_user_id`;
     * отправляет Receiver’у:

       * username автора (если есть),
       * отображаемое имя (first_name + last_name),
       * кнопку “Перейти в чат” с deep-link `tg://user?id=<sender_user_id>`.
4. Нигде в `callback_data` и в служебных текстах **не должно быть** чистого `sender_user_id`:

   * он используется только в deep-link, который идёт клиенту.

---

### 5.9. Антиспам и блокировки

* Рейтлимит для AnonSender:

  * ограничение отправки сообщений (например, X сообщений/минуту, Y сообщений/день),
  * хранить счётчики в Redis или Postgres.
* Receiver может пожаловаться на сообщение/автора:

  * флаг “reported” в `messages`,
  * при накоплении жалоб — блокировка автора (поле `is_blocked` в `users`).
* Заблокированным пользователям:

  * бот не позволяет отправлять новые валентинки, либо показывает сообщение о блокировке.

---

### 5.10. Интернационализация (i18n)

* Поддерживаем минимум RU и EN.
* Определение языка:

  * сохранённый выбор пользователя,
  * затем `language_code` Telegram,
  * затем язык по умолчанию.
* Все тексты — через словарь/po-файлы; в коде не должно быть “жёстко прошитых” строк в нескольких местах.
* Переключение языка в разделе “Настройки”.

---

### 5.11. Сохранение состояния при рестарте (устойчивость чатов)

**Жёсткое требование:**
При перезагрузке сервера/контейнера **не должны “слетать” чаты** и состояние диалогов.

1. Не использовать чисто in-memory состояние для FSM/ConversationHandler:

   * либо реализовать собственный persistence для `python-telegram-bot`, основанный на Postgres/Redis (`BasePersistence`);
   * либо реализовать свой FSM, в котором:

     * состояние (`state_name`) и контекст (payload) записываются в таблицу `dialog_states`:

       * `user_id`
       * `state`
       * `data` (jsonb)
       * timestamps.
2. При каждом входящем апдейте состояние пользователя определяется из БД/Redis, а не из памяти процесса.
3. Все сущности `messages`, `threads`, `thread_messages` хранятся в БД, поэтому переписка сохраняется независимо от рестартов.

---

### 5.12. Callback-данные и приватность ID

**Критическое требование безопасности:**

* В `callback_data` **запрещено** передавать:

  * `telegram_user_id`,
  * `chat_id`,
  * любые производные значения, по которым однозначно вычисляется ID.

Решение:

1. Вводится таблица `callback_tokens`:

   * `id` (PK)
   * `token` (строка, уникальная, например `cb_<base62>`),
   * `type` (enum: OPEN_MESSAGE, REPLY, REVEAL_AUTHOR, PAGINATE и т.п.)
   * `entity_id` (FK — например, `message_id` или `thread_id`),
   * `extra_data` (jsonb),
   * `expires_at` (timestamp).
2. В `callback_data` передаётся **только** `token` (например, `"cb_ABC123"`).
3. При нажатии кнопки:

   * по `token` в БД определяется `entity_id` и `type`;
   * текущий пользователь определяется исключительно по `callback_query.from.id`;
   * выполняется нужное действие.
4. Токены можно делать одноразовыми или с TTL.

---

### 5.13. Статистика для пользователя

Раздел “Статистика” для Receiver:

* Общая статистика:

  * количество полученных валентинок за период;
  * количество ответов;
  * количество раскрытий авторов (если такие происходили).
* По каждой ссылке:

  * количество полученных сообщений;
  * количество уникальных отправителей (если мы сохраняем `sender_user_id`).

---

## 6. Функциональные требования — Этап 2 (админка)

**Высокоуровнево (детализация может быть расширена перед началом Этапа 2):**

1. **Технологии:**

   * FastAPI + PostgreSQL (те же данные, что и у бота).
   * UI: на выбор — AdminJS, простой React/Next.js, либо Jinja-шаблоны.

2. **Аутентификация администраторов:**

   * логин/пароль;
   * роль: SUPERADMIN (опционально SUPPORT).

3. **Раздел “Пользователи”:**

   * список пользователей;
   * поиск по `telegram_user_id`, `username`;
   * просмотр профиля:

     * ссылки, сообщения, статистика.

4. **Раздел “Ссылки”:**

   * список ссылок;
   * поиск по владельцу и slug;
   * активация/деактивация/удаление.

5. **Раздел “Сообщения”:**

   * поиск по:

     * id сообщения,
     * sender/recipient,
     * тексту (по возможности full-text search).
   * Просмотр полной переписки (thread).

6. **Раздел “Жалобы/модерация”:**

   * список сообщений с жалобами;
   * блокировка пользователей/ссылок;
   * отметка сообщений как спам.

7. **Раздел “Статистика”:**

   * количество пользователей/ссылок;
   * динамика сообщений/дня;
   * статусы, количество раскрытий авторов.

---

## 7. Требования к базе данных (основные сущности)

(Типы — ориентировочно, под PostgreSQL.)

### 7.1. `users`

* `id` — PK, `bigserial`.
* `telegram_user_id` — `bigint`, unique.
* `username` — `varchar`, nullable.
* `first_name` — `varchar`, nullable.
* `last_name` — `varchar`, nullable.
* `language` — `varchar`, например `ru`, `en`.
* `is_blocked` — `boolean`, default `false`.
* `created_at` — `timestamp with time zone`.
* `updated_at` — `timestamp with time zone`.

### 7.2. `links`

* `id` — PK, `bigserial`.
* `owner_user_id` — FK → `users(id)`.
* `slug` — `varchar`, unique.
* `label` — `varchar`.
* `prompt` — `text`, nullable.
* `is_active` — `boolean`, default `true`.
* `created_at` — `timestamptz`.
* `updated_at` — `timestamptz`.
* `deleted_at` — `timestamptz`, nullable.

### 7.3. `messages`

* `id` — PK, `bigserial`.
* `link_id` — FK → `links(id)`.
* `recipient_user_id` — FK → `users(id)`.
* `sender_user_id` — FK → `users(id)`, nullable (если решим допускать полностью “внешних” отправителей).
* `text` — `text`.
* `is_reveal_allowed` — `boolean`, default `false`.
* `is_revealed` — `boolean`, default `false`.
* `status` — enum (например, `NEW`, `DELIVERED`, `READ`, `BLOCKED`).
* `is_reported` — `boolean`, default `false`.
* `created_at` — `timestamptz`.
* `delivered_at` — `timestamptz`, nullable.
* `read_at` — `timestamptz`, nullable.

### 7.4. `threads`

* `id` — PK, `bigserial`.
* `root_message_id` — FK → `messages(id)`.
* `created_at` — `timestamptz`.
* `closed_at` — `timestamptz`, nullable.

### 7.5. `thread_messages`

* `id` — PK, `bigserial`.
* `thread_id` — FK → `threads(id)`.
* `from_user_id` — FK → `users(id)`.
* `to_user_id` — FK → `users(id)`.
* `text` — `text`.
* `created_at` — `timestamptz`.
* `read_at` — `timestamptz`, nullable.

### 7.6. `callback_tokens`

* `id` — PK, `bigserial`.
* `token` — `varchar`, unique (строка вида `cb_...`).
* `type` — `varchar` или enum (`OPEN_MESSAGE`, `REPLY`, `REVEAL_AUTHOR`, `PAGINATE` и т.д.).
* `entity_id` — `bigint` (ID сообщения/треда и пр.).
* `extra_data` — `jsonb`, nullable.
* `expires_at` — `timestamptz`, nullable.

### 7.7. `dialog_states` (если реализуем свой FSM)

* `user_id` — FK → `users(id)`, PK.
* `state` — `varchar`.
* `data` — `jsonb`.
* `updated_at` — `timestamptz`.

---

## 8. Нефункциональные требования

### 8.1. Производительность и масштабируемость

* Целевые ориентиры (могут уточняться):

  * до 500k зарегистрированных пользователей;
  * до нескольких тысяч RPS по webhook в пике.
* Только webhook-режим.
* Возможность запуска нескольких экземпляров бота за reverse proxy (nginx/Caddy).
* Все состояния, влияющие на логику, должны быть в БД/Redis, а не в памяти процесса.

### 8.2. Безопасность и конфиденциальность

* Никаких `telegram_user_id`/`chat_id` в `callback_data` и в открытых текстах, кроме deep-link `tg://user?id=...` в момент раскрытия.
* Секреты (BOT_TOKEN, пароли, URL) — только в `.env`/секретах оркестратора.
* Админка (Этап 2) должна быть защищена авторизацией и (по желанию) ограничением по IP.

### 8.3. Логирование и ротация

* Использовать стандартный модуль `logging` с конфигурацией через код/файл.
* Логи:

  * формат: структурированный (как минимум включать timestamp, уровень, модуль, сообщение).
  * не логировать полные тексты сообщений пользователей в debug/info (по желанию — можно).
* Ротация:

  * либо через TimedRotatingFileHandler,
  * либо логирование в stdout и ротация средствами инфраструктуры.

### 8.4. Бэкапы и восстановление

* Ежедневные бэкапы PostgreSQL:

  * `pg_dump` или физические бэкапы.
  * хранение бэкапов не менее 14 дней (параметр уточняется).
* Процедура восстановления должна быть задокументирована.

---

## 9. Тестирование и качество

* Unit-тесты:

  * бизнес-логика (use-cases) без Telegram.
* Интеграционные тесты:

  * репозитории (Postgres),
  * обработчики основных сценариев.
* Нагрузочные тесты (минимальный smoke-load сценарий):

  * симуляция пачки webhook-апдейтов.

---

## 10. Деплой и окружения

* Окружения:

  * local (через `docker-compose`),
  * staging,
  * production.
* Для каждого окружения — свой `.env`.
* Dockerfile должен:

  * использовать Python 3.12 slim,
  * устанавливать `uv` и зависимости,
  * запускать бот-приложение (`python -m ...`) в async-режиме.


